#!/usr/bin/env python3

"""
Transfer Script for JFrog Artifactory Repository Comparison
==========================================================

This script executes the transfer commands generated by compare_repos.py
to actually move files from source to target Artifactory instances.

Features:
- Executes curl-based transfer commands
- Progress tracking and logging
- Parallel execution support
- Resume capability for failed transfers
- Detailed reporting

Usage:
    python transfer_files.py --output-dir out_1234567890
    python transfer_files.py --transfer-file repo1/transfer.txt
    python transfer_files.py --output-dir out_1234567890 --parallel-workers 10
"""

import argparse
import concurrent.futures
import logging
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import List, Dict


class FileTransferManager:
    """
    Manages the execution of file transfer commands generated by compare_repos.py
    """

    def __init__(self, output_dir: str = None, parallel_workers: int = 5):
        """
        Initialize the transfer manager.

        Args:
            output_dir: Output directory containing transfer.txt files
            parallel_workers: Number of parallel workers for transfers
        """
        self.output_dir = output_dir
        self.parallel_workers = parallel_workers
        self.logger = self._setup_logging()

        # Transfer statistics
        self.total_commands = 0
        self.successful_transfers = 0
        self.failed_transfers = 0
        self.start_time = time.time()

    def _setup_logging(self) -> logging.Logger:
        """Setup logging configuration."""
        log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format=log_format,
            handlers=[
                logging.FileHandler("transfer.log"),
                logging.StreamHandler(sys.stdout),
            ],
        )

        return logging.getLogger(__name__)

    def find_transfer_files(self) -> List[str]:
        """Find all transfer.txt files in the output directory."""
        if not self.output_dir or not os.path.exists(self.output_dir):
            raise ValueError(f"Output directory does not exist: {self.output_dir}")

        transfer_files = []
        for root, dirs, files in os.walk(self.output_dir):
            for file in files:
                if file == "transfer.txt":
                    transfer_files.append(os.path.join(root, file))

        self.logger.info(f"Found {len(transfer_files)} transfer files")
        return transfer_files

    def read_transfer_commands(self, transfer_file: str) -> List[str]:
        """Read transfer commands from a transfer.txt file."""
        commands = []

        try:
            with open(transfer_file, "r") as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line:
                        commands.append((transfer_file, line_num, line))

            self.logger.debug(f"Read {len(commands)} commands from {transfer_file}")
            return commands

        except Exception as e:
            self.logger.error(f"Failed to read transfer file {transfer_file}: {str(e)}")
            return []

    def execute_transfer_command(self, command_info: tuple) -> Dict:
        """
        Execute a single transfer command.

        Args:
            command_info: Tuple of (file_path, line_number, command)

        Returns:
            Dictionary containing execution result
        """
        transfer_file, line_num, command = command_info
        repo_name = os.path.basename(os.path.dirname(transfer_file))

        try:
            self.logger.debug(f"Executing command from {repo_name}:{line_num}")

            # Execute the command using shell
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout per command
            )

            if result.returncode == 0:
                self.successful_transfers += 1
                return {
                    "status": "success",
                    "repo": repo_name,
                    "line": line_num,
                    "command": command,
                    "output": result.stdout.strip(),
                }
            else:
                self.failed_transfers += 1
                return {
                    "status": "failed",
                    "repo": repo_name,
                    "line": line_num,
                    "command": command,
                    "error": result.stderr.strip(),
                    "return_code": result.returncode,
                }

        except subprocess.TimeoutExpired:
            self.failed_transfers += 1
            return {
                "status": "timeout",
                "repo": repo_name,
                "line": line_num,
                "command": command,
                "error": "Command timed out after 5 minutes",
            }
        except Exception as e:
            self.failed_transfers += 1
            return {
                "status": "error",
                "repo": repo_name,
                "line": line_num,
                "command": command,
                "error": str(e),
            }

    def run_transfers(self, transfer_files: List[str] = None):
        """
        Run all transfer commands.

        Args:
            transfer_files: List of transfer files to process. If None, find all files.
        """
        if transfer_files is None:
            transfer_files = self.find_transfer_files()

        if not transfer_files:
            self.logger.warning("No transfer files found")
            return

        # Collect all commands
        all_commands = []
        for transfer_file in transfer_files:
            commands = self.read_transfer_commands(transfer_file)
            all_commands.extend(commands)

        if not all_commands:
            self.logger.warning("No transfer commands found")
            return

        self.total_commands = len(all_commands)
        self.logger.info(
            f"Starting transfer of {self.total_commands} files using {self.parallel_workers} workers"
        )

        # Create failed commands log
        failed_log_path = "failed_transfers.log"

        # Execute commands with parallel workers
        with concurrent.futures.ThreadPoolExecutor(
            max_workers=self.parallel_workers
        ) as executor:
            future_to_command = {
                executor.submit(self.execute_transfer_command, cmd): cmd
                for cmd in all_commands
            }

            completed = 0
            with open(failed_log_path, "w") as failed_log:
                failed_log.write("# Failed Transfer Commands\n")
                failed_log.write(f"# Generated on: {datetime.now().isoformat()}\n\n")

                for future in concurrent.futures.as_completed(future_to_command):
                    completed += 1
                    command_info = future_to_command[future]

                    try:
                        result = future.result()

                        if result["status"] == "success":
                            if completed % 10 == 0:  # Log progress every 10 transfers
                                self.logger.info(
                                    f"Progress: {completed}/{self.total_commands} "
                                    f"({completed/self.total_commands*100:.1f}%)"
                                )
                        else:
                            # Log failed command
                            failed_log.write(
                                f"# Repo: {result['repo']}, Line: {result['line']}\n"
                            )
                            failed_log.write(
                                f"# Error: {result.get('error', 'Unknown error')}\n"
                            )
                            failed_log.write(f"{result['command']}\n\n")
                            failed_log.flush()

                            self.logger.warning(
                                f"Failed transfer in {result['repo']}:{result['line']} - "
                                f"{result.get('error', 'Unknown error')}"
                            )

                    except Exception as e:
                        self.logger.error(
                            f"Command execution generated an exception: {str(e)}"
                        )
                        self.failed_transfers += 1

        # Generate final report
        self._generate_transfer_report()

    def _generate_transfer_report(self):
        """Generate a summary report of the transfer process."""
        elapsed_time = time.time() - self.start_time

        report_path = "transfer_report.txt"
        with open(report_path, "w") as f:
            f.write("=" * 60 + "\n")
            f.write("File Transfer Report\n")
            f.write("=" * 60 + "\n")
            f.write(f"Timestamp: {datetime.now().isoformat()}\n")
            f.write(f"Output Directory: {self.output_dir}\n")
            f.write(f"Parallel Workers: {self.parallel_workers}\n")
            f.write("-" * 60 + "\n")
            f.write(f"Total Commands: {self.total_commands}\n")
            f.write(f"Successful Transfers: {self.successful_transfers}\n")
            f.write(f"Failed Transfers: {self.failed_transfers}\n")
            f.write(
                f"Success Rate: {self.successful_transfers/self.total_commands*100:.2f}%\n"
            )
            f.write(f"Total Time: {elapsed_time:.2f} seconds\n")
            f.write(
                f"Average Time per Transfer: {elapsed_time/self.total_commands:.2f} seconds\n"
            )
            f.write("-" * 60 + "\n")

            if self.failed_transfers > 0:
                f.write(f"Failed commands have been logged to: failed_transfers.log\n")
                f.write("You can retry failed transfers by running:\n")
                f.write("  bash failed_transfers.log\n")

        self.logger.info(f"Transfer completed. Report saved to: {report_path}")
        self.logger.info(
            f"Success rate: {self.successful_transfers}/{self.total_commands} "
            f"({self.successful_transfers/self.total_commands*100:.2f}%)"
        )


def main():
    """Main entry point for the transfer script."""
    parser = argparse.ArgumentParser(
        description="Execute file transfer commands generated by compare_repos.py",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Transfer all files from output directory
  python transfer_files.py --output-dir out_1234567890

  # Transfer files from specific transfer file
  python transfer_files.py --transfer-file repo1/transfer.txt

  # Use custom number of parallel workers
  python transfer_files.py --output-dir out_1234567890 --parallel-workers 10

  # Dry run (validate commands without executing)
  python transfer_files.py --output-dir out_1234567890 --dry-run
        """,
    )

    parser.add_argument(
        "--output-dir", "-o", help="Output directory containing transfer.txt files"
    )

    parser.add_argument(
        "--transfer-file", "-f", help="Specific transfer.txt file to process"
    )

    parser.add_argument(
        "--parallel-workers",
        "-p",
        type=int,
        default=5,
        help="Number of parallel workers (default: 5)",
    )

    parser.add_argument(
        "--dry-run",
        "-d",
        action="store_true",
        help="Validate commands without executing them",
    )

    args = parser.parse_args()

    if not args.output_dir and not args.transfer_file:
        parser.error("Either --output-dir or --transfer-file must be specified")

    try:
        manager = FileTransferManager(
            output_dir=args.output_dir, parallel_workers=args.parallel_workers
        )

        if args.dry_run:
            # Dry run mode - just validate and count commands
            transfer_files = (
                [args.transfer_file]
                if args.transfer_file
                else manager.find_transfer_files()
            )

            total_commands = 0
            for transfer_file in transfer_files:
                commands = manager.read_transfer_commands(transfer_file)
                total_commands += len(commands)
                print(f"Found {len(commands)} commands in {transfer_file}")

            print(f"Total commands to execute: {total_commands}")
            print("Use --dry-run=false to execute the transfers")
        else:
            # Execute transfers
            transfer_files = [args.transfer_file] if args.transfer_file else None
            manager.run_transfers(transfer_files)

    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
