#!/usr/bin/env python3

"""
Transfer Script for JFrog Artifactory Repository Comparison
==========================================================

This script executes the transfer commands generated by compare_repos.py
to actually move files from source to target Artifactory instances.

Features:
- Executes curl-based and JFrog CLI transfer commands
- Progress tracking and logging
- Parallel execution support
- Resume capability for failed transfers
- Detailed reporting
- Command type detection (curl vs JFrog CLI)

Usage:
    python transfer_files.py --output-dir out_1234567890
    python transfer_files.py --transfer-file repo1/transfer.txt
    python transfer_files.py --output-dir out_1234567890 --parallel-workers 10
    python transfer_files.py --output-dir out_1234567890 --command-type jfrog
"""

import argparse
import concurrent.futures
import logging
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import List, Dict


class FileTransferManager:
    """
    Manages the execution of file transfer commands generated by compare_repos.py
    """

    def __init__(
        self,
        output_dir: str = None,
        parallel_workers: int = 5,
        command_type: str = "auto",
    ):
        """
        Initialize the transfer manager.

        Args:
            output_dir: Output directory containing transfer.txt files
            parallel_workers: Number of parallel workers for transfers
            command_type: Type of commands to expect ("curl", "jfrog", "auto")
        """
        self.output_dir = output_dir
        self.parallel_workers = parallel_workers
        self.command_type = command_type
        self.logger = self._setup_logging()

        # Transfer statistics
        self.total_commands = 0
        self.successful_transfers = 0
        self.failed_transfers = 0
        self.start_time = time.time()

        # Command type detection
        self.detected_command_types = set()

    def _setup_logging(self) -> logging.Logger:
        """Setup logging configuration."""
        log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format=log_format,
            handlers=[
                logging.FileHandler("transfer.log"),
                logging.StreamHandler(sys.stdout),
            ],
        )

        return logging.getLogger(__name__)

    def detect_command_type(self, command: str) -> str:
        """
        Detect the type of transfer command.

        Args:
            command: The transfer command string

        Returns:
            Command type: "curl", "jfrog", or "unknown"
        """
        command_lower = command.lower().strip()

        # Check for JFrog CLI commands
        if (
            command_lower.startswith("jf rt")
            or "jf rt download" in command_lower
            or "jf rt upload" in command_lower
        ):
            return "jfrog"

        # Check for curl commands
        if command_lower.startswith("curl") or "curl -f -s" in command_lower:
            return "curl"

        return "unknown"

    def validate_prerequisites(self, command_types: set) -> bool:
        """
        Validate that required tools are available for the detected command types.

        Args:
            command_types: Set of detected command types

        Returns:
            True if all prerequisites are met, False otherwise
        """
        prerequisites_met = True

        for cmd_type in command_types:
            if cmd_type == "curl":
                try:
                    result = subprocess.run(
                        ["curl", "--version"], capture_output=True, timeout=10
                    )
                    if result.returncode != 0:
                        self.logger.error(
                            "curl is not available or not working properly"
                        )
                        prerequisites_met = False
                    else:
                        self.logger.debug("curl is available and working")
                except (subprocess.TimeoutExpired, FileNotFoundError):
                    self.logger.error(
                        "curl command not found. Please install curl to execute curl-based transfers"
                    )
                    prerequisites_met = False

            elif cmd_type == "jfrog":
                try:
                    result = subprocess.run(
                        ["jf", "--version"], capture_output=True, timeout=10
                    )
                    if result.returncode != 0:
                        self.logger.error(
                            "JFrog CLI is not available or not working properly"
                        )
                        prerequisites_met = False
                    else:
                        self.logger.debug("JFrog CLI is available and working")
                        # Additional check for server configurations
                        try:
                            config_result = subprocess.run(
                                ["jf", "config", "show"],
                                capture_output=True,
                                timeout=10,
                            )
                            if config_result.returncode == 0:
                                self.logger.debug("JFrog CLI has configured servers")
                            else:
                                self.logger.warning(
                                    "JFrog CLI is available but may not have configured servers. Run 'jf config add' to configure servers."
                                )
                        except:
                            self.logger.warning(
                                "Could not check JFrog CLI server configuration"
                            )
                except (subprocess.TimeoutExpired, FileNotFoundError):
                    self.logger.error(
                        "JFrog CLI (jf) command not found. Please install JFrog CLI to execute JFrog CLI-based transfers"
                    )
                    prerequisites_met = False

        return prerequisites_met

    def find_transfer_files(self) -> List[str]:
        """Find all transfer.txt files in the output directory."""
        if not self.output_dir or not os.path.exists(self.output_dir):
            raise ValueError(f"Output directory does not exist: {self.output_dir}")

        transfer_files = []
        for root, dirs, files in os.walk(self.output_dir):
            for file in files:
                if file == "transfer.txt":
                    transfer_files.append(os.path.join(root, file))

        self.logger.info(f"Found {len(transfer_files)} transfer files")
        return transfer_files

    def read_transfer_commands(self, transfer_file: str) -> List[str]:
        """Read transfer commands from a transfer.txt file."""
        commands = []

        try:
            with open(transfer_file, "r") as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line and not line.startswith(
                        "#"
                    ):  # Skip empty lines and comments
                        # Detect command type
                        cmd_type = self.detect_command_type(line)
                        self.detected_command_types.add(cmd_type)

                        commands.append((transfer_file, line_num, line, cmd_type))

            self.logger.debug(f"Read {len(commands)} commands from {transfer_file}")
            return commands

        except Exception as e:
            self.logger.error(f"Failed to read transfer file {transfer_file}: {str(e)}")
            return []

    def execute_transfer_command(self, command_info: tuple) -> Dict:
        """
        Execute a single transfer command.

        Args:
            command_info: Tuple of (file_path, line_number, command, command_type)

        Returns:
            Dictionary containing execution result
        """
        transfer_file, line_num, command, cmd_type = command_info
        repo_name = os.path.basename(os.path.dirname(transfer_file))

        try:
            self.logger.debug(
                f"Executing {cmd_type} command from {repo_name}:{line_num}"
            )

            # Set timeout based on command type
            timeout = (
                600 if cmd_type == "jfrog" else 300
            )  # JFrog CLI might need more time

            # Execute the command using shell
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout,
            )

            if result.returncode == 0:
                self.successful_transfers += 1
                return {
                    "status": "success",
                    "repo": repo_name,
                    "line": line_num,
                    "command": command,
                    "command_type": cmd_type,
                    "output": result.stdout.strip(),
                }
            else:
                self.failed_transfers += 1
                return {
                    "status": "failed",
                    "repo": repo_name,
                    "line": line_num,
                    "command": command,
                    "command_type": cmd_type,
                    "error": result.stderr.strip(),
                    "return_code": result.returncode,
                }

        except subprocess.TimeoutExpired:
            self.failed_transfers += 1
            timeout_msg = f"Command timed out after {timeout//60} minutes"
            return {
                "status": "timeout",
                "repo": repo_name,
                "line": line_num,
                "command": command,
                "command_type": cmd_type,
                "error": timeout_msg,
            }
        except Exception as e:
            self.failed_transfers += 1
            return {
                "status": "error",
                "repo": repo_name,
                "line": line_num,
                "command": command,
                "command_type": cmd_type,
                "error": str(e),
            }

    def run_transfers(self, transfer_files: List[str] = None):
        """
        Run all transfer commands.

        Args:
            transfer_files: List of transfer files to process. If None, find all files.
        """
        if transfer_files is None:
            transfer_files = self.find_transfer_files()

        if not transfer_files:
            self.logger.warning("No transfer files found")
            return

        # Collect all commands and detect command types
        all_commands = []
        for transfer_file in transfer_files:
            commands = self.read_transfer_commands(transfer_file)
            all_commands.extend(commands)

        if not all_commands:
            self.logger.warning("No transfer commands found")
            return

        # Report detected command types
        if self.detected_command_types:
            self.logger.info(
                f"Detected command types: {', '.join(sorted(self.detected_command_types))}"
            )

            # Filter out unknown command types for validation
            known_types = {
                t for t in self.detected_command_types if t in ["curl", "jfrog"]
            }

            if "unknown" in self.detected_command_types:
                self.logger.warning(
                    "Some commands have unknown format and may not execute properly"
                )

            # Validate prerequisites for known command types
            if known_types:
                self.logger.info("Validating prerequisites...")
                if not self.validate_prerequisites(known_types):
                    self.logger.error(
                        "Prerequisites not met. Please install missing tools before proceeding."
                    )
                    return
                self.logger.info("Prerequisites validated successfully")

        self.total_commands = len(all_commands)
        self.logger.info(
            f"Starting transfer of {self.total_commands} files using {self.parallel_workers} workers"
        )

        # Create failed commands log
        failed_log_path = "failed_transfers.log"

        # Execute commands with parallel workers
        with concurrent.futures.ThreadPoolExecutor(
            max_workers=self.parallel_workers
        ) as executor:
            future_to_command = {
                executor.submit(self.execute_transfer_command, cmd): cmd
                for cmd in all_commands
            }

            completed = 0
            with open(failed_log_path, "w") as failed_log:
                failed_log.write("# Failed Transfer Commands\n")
                failed_log.write(f"# Generated on: {datetime.now().isoformat()}\n")
                failed_log.write(
                    f"# Command types detected: {', '.join(sorted(self.detected_command_types))}\n\n"
                )

                for future in concurrent.futures.as_completed(future_to_command):
                    completed += 1
                    command_info = future_to_command[future]

                    try:
                        result = future.result()

                        if result["status"] == "success":
                            if completed % 10 == 0:  # Log progress every 10 transfers
                                self.logger.info(
                                    f"Progress: {completed}/{self.total_commands} "
                                    f"({completed/self.total_commands*100:.1f}%)"
                                )
                        else:
                            # Log failed command
                            failed_log.write(
                                f"# Repo: {result['repo']}, Line: {result['line']}, Type: {result.get('command_type', 'unknown')}\n"
                            )
                            failed_log.write(
                                f"# Error: {result.get('error', 'Unknown error')}\n"
                            )
                            failed_log.write(f"{result['command']}\n\n")
                            failed_log.flush()

                            self.logger.warning(
                                f"Failed {result.get('command_type', 'unknown')} transfer in {result['repo']}:{result['line']} - "
                                f"{result.get('error', 'Unknown error')}"
                            )

                    except Exception as e:
                        self.logger.error(
                            f"Command execution generated an exception: {str(e)}"
                        )
                        self.failed_transfers += 1

        # Generate final report
        self._generate_transfer_report()

    def _generate_transfer_report(self):
        """Generate a summary report of the transfer process."""
        elapsed_time = time.time() - self.start_time

        report_path = "transfer_report.txt"
        with open(report_path, "w") as f:
            f.write("=" * 60 + "\n")
            f.write("File Transfer Report\n")
            f.write("=" * 60 + "\n")
            f.write(f"Timestamp: {datetime.now().isoformat()}\n")
            f.write(f"Output Directory: {self.output_dir}\n")
            f.write(f"Parallel Workers: {self.parallel_workers}\n")
            f.write(
                f"Command Types: {', '.join(sorted(self.detected_command_types))}\n"
            )
            f.write("-" * 60 + "\n")
            f.write(f"Total Commands: {self.total_commands}\n")
            f.write(f"Successful Transfers: {self.successful_transfers}\n")
            f.write(f"Failed Transfers: {self.failed_transfers}\n")
            if self.total_commands > 0:
                f.write(
                    f"Success Rate: {self.successful_transfers/self.total_commands*100:.2f}%\n"
                )
            f.write(f"Total Time: {elapsed_time:.2f} seconds\n")
            if self.total_commands > 0:
                f.write(
                    f"Average Time per Transfer: {elapsed_time/self.total_commands:.2f} seconds\n"
                )
            f.write("-" * 60 + "\n")

            if self.failed_transfers > 0:
                f.write(f"Failed commands have been logged to: failed_transfers.log\n")
                f.write("You can retry failed transfers by running:\n")
                f.write("  bash failed_transfers.log\n")
                f.write("  # OR process the failed commands file:\n")
                f.write(
                    "  python transfer_files.py --transfer-file failed_transfers.log\n"
                )

        self.logger.info(f"Transfer completed. Report saved to: {report_path}")
        if self.total_commands > 0:
            self.logger.info(
                f"Success rate: {self.successful_transfers}/{self.total_commands} "
                f"({self.successful_transfers/self.total_commands*100:.2f}%)"
            )


def main():
    """Main entry point for the transfer script."""
    parser = argparse.ArgumentParser(
        description="Execute file transfer commands generated by compare_repos.py",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Transfer all files from output directory
  python transfer_files.py --output-dir out_1234567890

  # Transfer files from specific transfer file
  python transfer_files.py --transfer-file repo1/transfer.txt

  # Use custom number of parallel workers
  python transfer_files.py --output-dir out_1234567890 --parallel-workers 10

  # Process JFrog CLI commands specifically
  python transfer_files.py --output-dir out_1234567890 --command-type jfrog

  # Dry run (validate commands without executing)
  python transfer_files.py --output-dir out_1234567890 --dry-run
        """,
    )

    parser.add_argument(
        "--output-dir", "-o", help="Output directory containing transfer.txt files"
    )

    parser.add_argument(
        "--transfer-file", "-f", help="Specific transfer.txt file to process"
    )

    parser.add_argument(
        "--parallel-workers",
        "-p",
        type=int,
        default=5,
        help="Number of parallel workers (default: 5)",
    )

    parser.add_argument(
        "--dry-run",
        "-d",
        action="store_true",
        help="Validate commands without executing them",
    )

    parser.add_argument(
        "--command-type",
        choices=["curl", "jfrog", "auto"],
        default="auto",
        help="Expected command type (default: auto-detect)",
    )

    args = parser.parse_args()

    if not args.output_dir and not args.transfer_file:
        parser.error("Either --output-dir or --transfer-file must be specified")

    try:
        manager = FileTransferManager(
            output_dir=args.output_dir,
            parallel_workers=args.parallel_workers,
            command_type=args.command_type,
        )

        if args.dry_run:
            # Dry run mode - just validate and count commands
            transfer_files = (
                [args.transfer_file]
                if args.transfer_file
                else manager.find_transfer_files()
            )

            total_commands = 0
            command_types = set()

            for transfer_file in transfer_files:
                commands = manager.read_transfer_commands(transfer_file)
                total_commands += len(commands)

                # Collect command types for reporting
                for _, _, _, cmd_type in commands:
                    command_types.add(cmd_type)

                print(f"Found {len(commands)} commands in {transfer_file}")

            print(f"Total commands to execute: {total_commands}")
            if command_types:
                print(f"Command types detected: {', '.join(sorted(command_types))}")

                # Check prerequisites in dry run mode
                known_types = {t for t in command_types if t in ["curl", "jfrog"]}
                if known_types:
                    print("Checking prerequisites...")
                    if manager.validate_prerequisites(known_types):
                        print("✅ All prerequisites met")
                    else:
                        print("❌ Some prerequisites missing")

            print("Use without --dry-run to execute the transfers")
        else:
            # Execute transfers
            transfer_files = [args.transfer_file] if args.transfer_file else None
            manager.run_transfers(transfer_files)

    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
